#!/usr/bin/env luajit

local R = require "re"
local J = require "cjson"
local Month = {
	jan = 1,
	feb = 2,
	mar = 3,
	apr = 4,
	may = 5,
	jun = 6,
	jul = 7,
	aug = 8,
	sep = 9,
	oct = 10,
	nov = 11,
	dec = 12,
}

local Day = {
	sun = 1,
	mon = 2,
	tue = 3,
	wed = 4,
	thu = 5,
	fri = 6,
	sat = 7,
}

local input = string.lower(table.concat(arg, " "))

local date_pattern = R.compile [[

	range <- {| date ( %s* ',' %s* date )^-1 {:consumed: {} :} |}

	date <- {|
		(
			{:en: 'yesterday' / 'today' / 'tomorrow' :}
			/
			{:day: {|
				{:sign: ( 'this' / 'next' / 'last' )^-1 :}
				%s* ( {:len: %d+ :} ordinal_suffix^-1 )^-1
				%s* day_en
			|} :}
			/
			date_ymd / date_en
		)^-1

		(
			%s*
			{:interval: {|
				{:sign: [+-] :}
				%s* {:len: %d+ :}
				%s* {:unit: {'d'}'ay'^-1 / {'w'}'eek'^-1 / {'m'}'onth'^-1 / {'y'}'ear'^-1 :} 's'^-1
			|} :}
		)^-1
	|}

	date_ymd <- {:date_ymd: {|
		( year [-/] )^-1
		{:mon_num: '1'[012] / '0'^-1[1-9] :}
		[-/] day_num
	|} :}

	date_en <- {:date_en: {|
		( mon_en %s+ day_num / day_num %s+ mon_en ) (%s+ year)^-1
	|} :}

	year <- {:year: %d^4 :}

	mon_en <- {:mon_en:
		  { 'jan' } 'uary'   ^-1
		/ { 'feb' } 'ruary'  ^-1
		/ { 'mar' } 'ch'     ^-1
		/ { 'apr' } 'il'     ^-1
		/ { 'may' }
		/ { 'jun' } 'e'      ^-1
		/ { 'jul' } 'y'      ^-1
		/ { 'aug' } 'ust'    ^-1
		/ { 'sep' } 'tember' ^-1
		/ { 'oct' } 'ober'   ^-1
		/ { 'nov' } 'ember'  ^-1
		/ { 'dec' } 'ember'  ^-1
	:}

	day_num <-
		{:day_num: [12][0-9] / [3][01] / [0]^-1[1-9] :}
		ordinal_suffix^-1

	ordinal_suffix <-
		 'st' / 'nd' / 'rd' / 'th'

	day_en <- {:day_en:
		  { 'sun' } 'day'    ^-1
		/ { 'mon' } 'day'    ^-1
		/ { 'tue' } 'sday'   ^-1
		/ { 'wed' } 'nesday' ^-1
		/ { 'thu' } 'rsday'  ^-1
		/ { 'fri' } 'day'    ^-1
		/ { 'sat' } 'urday'  ^-1
	:}

]]

local plus_days = function (dt, n)
	return os.date("*t", os.time(dt) + n * 86400)
end

local normalize = {
	consumed = function (mm, input)
		if #input ~= mm.consumed - 1 then
			if mm.consumed == 1 then
				io.stderr:write('Giving up.\n')
				os.exit(-1)
			else
				io.stderr:write('Trying "' .. input:sub(1, mm.consumed -1) .. '"\n')
			end
		end
		mm.consumed = nil
	end,

	range = function (mm)
		if mm[2] == nil then
			mm[2] = mm[1]
			return false
		else
			return true
		end
	end,

	date = function (m)
		if m._date then return end

		if m.en == nil and m.day == nil and m.date_abs == nil then
			m.en = 'today'
		end
	end,

	en = function (m)
		if m.en == nil then
			return
		end

		m._date = os.date('*t')

		if m.en == 'yesterday' then
			m._date.day = m._date.day - 1
		elseif m.en == 'tomorrow' then
			m._date.day = m._date.day + 1
		end
		m.en = nil
	end,

	day = function (m)
		if m.day == nil then
			return
		end

		if m._date then
			return
		end

		local now = os.date('*t')
		local target, today = Day[m.day.day_en], now.wday

		-- we want to add delta days
		local delta = target - today
		if delta < 0 then delta = delta + 7 end

		if m.day.sign == 'last' then
			delta = delta - 7
			if m.day.len then
				delta = delta - 7 * (m.day.len - 1)
			end
		else
			-- on a friday, "next friday" is a week away
			if target == today and m.day.sign == 'next' then
				delta = 7
			end
			if m.day.len then
				delta = delta + 7 * (m.day.len - 1)
			end
		end

		m._message = 'adding ' .. delta .. ' days'
		m._date = plus_days(now, delta)
		m.day = nil
	end,

	interval = function (m)
	end,

	date_ymd = function (m)
		if m.date_ymd == nil then
			return
		end

		m._date = os.date('*t')
		local d, _d = m.date_ymd, m._date
		_d.day = d.day_num
		_d.month = d.mon_num
		_d.year = d.year

		m.date_ymd = nil
	end,

	date_en = function (m)
		if m.date_en == nil then
			return
		end

		m._date = os.date('*t')

		local d, _d = m.date_en, m._date
		_d.day = d.day_num
		_d.month = Month[d.mon_en]
		if d.year then
			_d.year = d.year
		end

		m.date_en = nil
	end,

}

local match = date_pattern:match(input)

normalize.consumed(match, input)

local different = normalize.range(match)

for k,v in pairs({ 'date', 'en', 'day', 'date_en', 'date_ymd', 'interval' }) do
	normalize[v](match[1])
	if different then
		normalize[v](match[2])
	end
end

print (J.encode(match))

